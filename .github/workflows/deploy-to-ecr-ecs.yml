name: Build → Push to ECR → Update ECS

on:
  push:
    branches: [ main ]

env:
  ECR_REPOSITORY: devops-microservice
  CONTAINER_NAME: container
  CONTAINER_PORT: 80
  CLUSTER_NAME: devops-cluster
  SERVICE_NAME: ecs-task-service-c7qhc25h    # update if different

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          set -euo pipefail
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} \
            | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com

      - name: Build Docker image
        run: |
          set -euo pipefail
          docker build -t $ECR_REPOSITORY .

      - name: Tag image for ECR
        run: |
          set -euo pipefail
          docker tag $ECR_REPOSITORY:latest ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/$ECR_REPOSITORY:latest

      - name: Create ECR repo if not exists
        run: |
          set -euo pipefail
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY

      - name: Push image to ECR
        run: |
          set -euo pipefail
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/$ECR_REPOSITORY:latest

      - name: Register new task definition and update ECS service (verbose debug)
        env:
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          TASK_FAMILY: devops-microservice-task
          CLUSTER_NAME: ${{ env.CLUSTER_NAME }}
          SERVICE_NAME: ${{ env.SERVICE_NAME }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          CONTAINER_PORT: ${{ env.CONTAINER_PORT }}
        run: |
          set -euo pipefail
          set -x

          echo "===== Environment summary (secrets hidden) ====="
          for v in AWS_REGION AWS_ACCOUNT_ID ECR_REPOSITORY TASK_FAMILY CLUSTER_NAME SERVICE_NAME CONTAINER_NAME CONTAINER_PORT; do
            val="${!v:-}"
            if [ -z "$val" ]; then
              echo "ENV MISSING -> $v = <EMPTY>"
            else
              echo "$v = $val"
            fi
          done
          echo "==============================================="

          # install jq if missing so JSON prints don't fail
          if ! command -v jq > /dev/null 2>&1; then
            echo "Installing jq..."
            sudo apt-get update -y
            sudo apt-get install -y jq || true
          fi

          # validate AWS creds
          echo "Checking AWS identity..."
          if ! aws sts get-caller-identity --region "${AWS_REGION}"; then
            echo "ERROR: AWS CLI credentials invalid or AWS_REGION wrong. Check GitHub secrets." >&2
            exit 5
          fi

          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:latest"
          export IMAGE_URI
          echo "IMAGE_URI = ${IMAGE_URI}"

          # ensure required env variables present
          for v in TASK_FAMILY CLUSTER_NAME SERVICE_NAME CONTAINER_NAME CONTAINER_PORT IMAGE_URI; do
            if [ -z "${!v:-}" ]; then
              echo "ERROR: Required env var '$v' is empty" >&2
              exit 6
            fi
          done

          # build taskdef.json with shell here-doc (variables expanded)
          cat > taskdef.json <<EOF
{
  "family": "${TASK_FAMILY}",
  "networkMode": "awsvpc",
  "executionRoleArn": "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::${AWS_ACCOUNT_ID}:role/ecsTaskExecutionRole",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "containerDefinitions": [
    {
      "name": "${CONTAINER_NAME}",
      "image": "${IMAGE_URI}",
      "portMappings": [
        {
          "containerPort": ${CONTAINER_PORT},
          "protocol": "tcp"
        }
      ],
      "essential": true,
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/${SERVICE_NAME}",
          "awslogs-region": "${AWS_REGION}",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
EOF

          echo "===== Generated taskdef.json ====="
          if command -v jq > /dev/null 2>&1; then
            jq . taskdef.json
          else
            cat taskdef.json
          fi
          echo "================================="

          echo "Registering task definition..."
          if ! REG_OUT=$(aws ecs register-task-definition --cli-input-json file://taskdef.json 2>&1); then
            echo "ERROR: register-task-definition failed" >&2
            echo "$REG_OUT" >&2
            exit 7
          else
            echo "register-task-definition succeeded"
            echo "$REG_OUT" | jq . || echo "$REG_OUT"
          fi

          echo "Updating ECS service (force new deployment)..."
          if ! UPD_OUT=$(aws ecs update-service --cluster "${CLUSTER_NAME}" --service "${SERVICE_NAME}" --force-new-deployment --region "${AWS_REGION}" 2>&1); then
            echo "ERROR: update-service failed" >&2
            echo "$UPD_OUT" >&2
            exit 8
          else
            echo "update-service succeeded"
            echo "$UPD_OUT" | jq . || echo "$UPD_OUT"
          fi

          echo "Deployment triggered successfully. Check ECS console for new tasks."
